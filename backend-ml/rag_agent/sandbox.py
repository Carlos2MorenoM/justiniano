import docker
import os
import logging
from typing import Tuple, Optional

# Configure logging for the sandbox module
logger = logging.getLogger(__name__)

class DockerSandbox:
    """
    Manages the execution of untrusted Python code within an isolated Docker container.
    
    This class handles the creation of ephemeral containers, volume mounting for 
    file exchange, and execution of Python scripts generated by the LLM Agent.
    """

    def __init__(self, base_image: str = "python:3.10-slim", volume_name: str = "justiniano_shared_data"):
        """
        Initializes the Sandbox environment.

        Args:
            base_image: The Docker image to use for the ephemeral container.
            volume_name: The name of the Docker volume used to share files between 
                         the main application and the sandbox container. 
                         Must match the volume defined in docker-compose.yml.
        """
        self.client = docker.from_env()
        self.base_image = base_image
        self.volume_name = volume_name
        
        # This is the path INSIDE backend-ml where the shared volume is mounted
        self.host_mount_point = "/app/shared_data"
        
        # This is the path INSIDE the ephemeral sandbox container
        self.sandbox_mount_point = "/workspace"

    def ensure_image_exists(self):
        """
        Checks if the base image exists locally, pulling it if necessary.
        This prevents execution delays or errors during the first run.
        """
        try:
            self.client.images.get(self.base_image)
        except docker.errors.ImageNotFound:
            logger.info(f"Image {self.base_image} not found. Pulling...")
            self.client.images.pull(self.base_image)
            logger.info(f"Image {self.base_image} pulled successfully.")

    def run_code(self, code: str, context_id: str) -> Tuple[str, str, bool]:
        """
        Executes the provided Python code string inside a fresh Docker container.

        Args:
            code: The raw Python code string to execute.
            context_id: A unique identifier (e.g., UUID) to isolate files for this execution.

        Returns:
            A tuple containing:
            - stdout (str): Standard output logs.
            - stderr (str): Standard error logs.
            - success (bool): True if exit code was 0, False otherwise.
        """
        self.ensure_image_exists()

        # 1. Prepare the workspace directory inside the shared volume
        # We create a specific folder for this run to avoid collisions
        work_dir = os.path.join(self.host_mount_point, context_id)
        os.makedirs(work_dir, exist_ok=True)

        # 2. Write the LLM-generated code to a file visible to the sandbox
        script_path = os.path.join(work_dir, "script.py")
        with open(script_path, "w", encoding="utf-8") as f:
            f.write(code)
        
        logger.info(f"Executing sandbox code for context: {context_id}")

        container = None
        try:
            # 3. Spawn the ephemeral container
            # We mount the shared volume so the container sees the script and files
            container = self.client.containers.run(
                image=self.base_image,
                command=f"python {self.sandbox_mount_point}/{context_id}/script.py",
                volumes={
                    self.volume_name: {'bind': self.sandbox_mount_point, 'mode': 'rw'}
                },
                working_dir=f"{self.sandbox_mount_point}/{context_id}",
                detach=True,
                # Security constraints (optional but recommended)
                # network_mode="none", # Uncomment to disable internet access for the agent
                mem_limit="512m",      # Limit RAM usage
            )

            # 4. Wait for execution to finish
            result = container.wait(timeout=30) # 30 seconds hard timeout
            exit_code = result['StatusCode']

            # 5. Capture logs
            logs = container.logs(stdout=True, stderr=True)
            logs_decoded = logs.decode('utf-8')

            # Separate crude simulation of stdout/stderr parsing if needed, 
            # but Docker combines them in the simple .logs() call usually.
            
            logger.info(f"Sandbox execution finished with exit code {exit_code}")
            
            return logs_decoded, "", (exit_code == 0)

        except Exception as e:
            logger.error(f"Sandbox execution failed: {str(e)}")
            return "", str(e), False
        
        finally:
            # 6. Cleanup: Always remove the container
            if container:
                try:
                    container.remove(force=True)
                except Exception:
                    pass